package com.template.springMVCtemplate.model;

import com.template.springMVCtemplate.model.mappingExample.ModelForManyToManyUnidirectional;
import com.template.springMVCtemplate.model.mappingExample.ModelForOneToOne;
import com.template.springMVCtemplate.model.mappingExample.ModelForOneToOneBidirectional;
import com.template.springMVCtemplate.model.mappingExample.ModelForOneToOneForiegnKey;

import javax.persistence.*;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import java.io.Serializable;
import java.util.*;

/**
 * Created by ud on 18/4/17.
 *
 * In this package we write all the domain models which we map to database.
 *
 * @Description : Below are the various annotations that can be used to declare
 * a Model and its corresponding table in db
 *
 * Note :It is always desirable that each and every model class implements Serializable.And should olways override
 * toString(),equals() and hashCode().
 *
 * @Entity : Each class annotated with this corresponds to a table in Database.It also informs hibernate to use
 * this as an entity bean. it must have a no-argument
 *
 * @Table(value ="TABLE_NAME") :This explicitly declares the table to which this model should be mapped in db.
 * If table name or this annotation is not provided hibernate will find a table corresponding to the class
 * name and if no such table is found it will create a new table with the class attributes as its columns.
 *      #It has 4 attributes :
 *          1.name :Defines the table name of the DB
 *          2.schema :
 *          3.catalog :
 *          4.uniqueConstraints : It applies unique constraint in the column specified.
 *       For example :
 *       @Table(name="tbl_sky", uniqueConstraints = {@UniqueConstraint(columnNames={"month", "day"})})
 *
 *@Id annotation lets you define which property is the identifier(primary_key) of your entity.
 *This property can be set by the application itself or be generated by Hibernate (preferred).The @id can be
 * uto-generated by using below four types of strategy declared by @GeneratedValue annotation.
 *
 * @GeneratedValue : This annotation states the strategy to be used for ID generation.
 *      #The various Strategies are :
 *          1.GenerationType.AUTO :Its a default strategy used,if no strategy is specified.uses the global number
 *                                 generator to generate a primary key for every new entity object.These generated values
 *                                 are unique at the database level and are never recycled.
 *
 *          2.GenerationType.IDENTITY : The IDENTITY strategy also generates an automatic value during commit for every new entity object.
 *                                      The difference is that a separate identity generator is managed per type hierarchy, so generated values are
 *                                      unique only per type hierarchy.
 *
 *          3.GenerationType.SEQUENCE :The sequence strategy consists of two parts - defining a named sequence and using the named sequence in one or more
 *                                     fields in one or more classes. The @SequenceGenerator annotation is used to define a sequence and accepts a name,
 *                                     an initial value (the default is 1) and an allocation size (the default is 50). A sequence is global to the application
 *                                     and can be used by one or more fields in one or more classes. The SEQUENCE strategy is used in the @GeneratedValue
 *                                     annotation to attach the given field to the previously defined named sequence:he SEQUENCE strategy generates an automatic
 *                                     value as soon as a new entity object is persisted (i.e. before commit). This may be useful when the primary key value is needed earlier.
 *                                     To minimize round trips to the database server, IDs are allocated in groups. The number of IDs in each allocation is specified by the
 *                                     allocationSize attribute. It is possible that some of the IDs in a given allocation will not be used. Therefore, this strategy does not
 *                                     guarantee there will be no gaps in sequence values.
 *
 *          4.GenerationType.TABLE : TABLE and SEQUENCE strategies are almost identical.A tiny difference is related to the initial value attribute. Whereas the SEQUENCE strategy
 *          maintains the next sequence number to be used the TABLE strategy maintains the last value that was used.
 *
 *@Column annotation is used to specify the details of the column to which a field or property will be mapped. You can use column annotation with the following most commonly
 * used attributes:
 *      1.name :attribute permits the name of the column to be explicitly specified.
 *      2.length :attribute permits the size of the column used to map a value particularly for a String value.
 *      3.nullable :attribute permits the column to be marked NOT NULL when the schema is generated.
 *      4.unique :attribute permits the column to be marked as containing only unique values.
 *
 *@OneToOne : This indicates that there is one to one mapping between Sample_Table and ModelForOneToOne.It also indicates
 * that ModelForOneToOne is dependent on Sample_Table.Since there is no existance of ModelForOneToOne without Sample_Table
 * we have the attribute in @OneToOne as Cascade.
 *      #cascade : Strategy used when deleting a parent object
 *      #mappedBy: mappedBy attribute are always put(annotated) on the inverse side of relation ship and specifies with itâ€™s
 *                 attribute value, the owner of the relationship.With this declaration, we ask hibernate to go and find the
 *                 student property of Address class to know how to manage the relationship/perform some operation
 * @Todo : Please refer ModelForOneToOne for various attributes that can be used with @OneToOne.
 *
 * @PrimaryKeyJoinColumn : This indicates that the dependent table will have the same primary key as that of main table.
 *
 * @JoinColumn : maps on a seperate column in database but will still point to primary key of address table
 *
 * @JoinTable indicates that there is a link table which joins two tables via containing there keys.This annotation
 * is mainly used on the owning side of the relationship.joinColumns refers to the column name of owning side(ID of SampleModel),
 * and inverseJoinColumns refers to the column of inverse side of relationship(MANY_ID of ModelForManyToManyUnidirectional).
 * Primary key of this joined table is combination of ID & MANY_ID.
 *
 * We can also put some validation constraint using JSR303 and hibernate-validator.
 * Here JSR303 is a specification and hibernate-validator is the implementation.
 * Annotation such as :
 * @Size: Specifies the length of the fields
 * @NotNull: Field should not be null
 * @DateTimeFormat(pattern="dd/MM/yyyy") :Used in validating dates when we require that dates should be entered in a
 *                                        specified format.
 * @Past : Also used with date to set the constraint that date should be a past date as compared to today.
 * @Email: Validates a email address
 * @NotEmpty: checks if the field is empty.
 * Note : @Email and @NotEmpty are part of hibernate-validater and not provided in JSR303 specification.
 *
 *
 *
 */

@Entity
//@SequenceGenerator(name="seq", initialValue=1, allocationSize=100) -> It generates the sequence_id ,Can be declared in other class its as global visibility.
//@SequenceGenerator(name="tab", initialValue=0, allocationSize=100) -> It generates the sequence_id ,Can be declared in other class its as global visibility.
@Table(name = "SAMPLE_TABLE")
public class SampleModel implements Serializable{

    @Id
    // Example @GeneratedValue(strategy = GenerationType.SEQUENCE ,generator="seq")
    // Example @GeneratedValue(strategy = GenerationType.TABLE ,generator="tab")
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "id",length = 2,nullable = true)
    private int id;

    @NotNull
    @Size(min = 1,max = 33)
    @Column(name = "name",length = 34,nullable = true)
    private String name;


   /* @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn
    private ModelForOneToOne oneToOne;*/


    @OneToOne(mappedBy = "sampleModel",cascade = CascadeType.ALL) //A bidirectional strategy
    private ModelForOneToOneBidirectional oneToOneBidirectional;


    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "FOREIGN_ID")
    private ModelForOneToOneForiegnKey oneToOneForiegnKey;

    @ManyToMany(cascade = CascadeType.MERGE,fetch = FetchType.LAZY)
    @JoinTable(name="MANY_TO_MANY",
                joinColumns = {@JoinColumn(name = "id")},
                inverseJoinColumns = {@JoinColumn(name = "MANY_ID")})
    private Set<ModelForManyToManyUnidirectional> manyUnidirectionals=new HashSet<ModelForManyToManyUnidirectional>();

    public Set<ModelForManyToManyUnidirectional> getManyUnidirectionals() {
        return manyUnidirectionals;
    }

    public void setManyUnidirectionals(Set<ModelForManyToManyUnidirectional> manyUnidirectionals) {
        this.manyUnidirectionals = manyUnidirectionals;
    }

    /*public ModelForOneToOne getOneToOne() {
        return oneToOne;
    }

    public void setOneToOne(ModelForOneToOne oneToOne) {
        this.oneToOne = oneToOne;
    }*/

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public ModelForOneToOneBidirectional getOneToOneBidirectional() {
        return oneToOneBidirectional;
    }

    public void setOneToOneBidirectional(ModelForOneToOneBidirectional oneToOneBidirectional) {
        this.oneToOneBidirectional = oneToOneBidirectional;
    }

    public ModelForOneToOneForiegnKey getOneToOneForiegnKey() {
        return oneToOneForiegnKey;
    }

    public void setOneToOneForiegnKey(ModelForOneToOneForiegnKey oneToOneForiegnKey) {
        this.oneToOneForiegnKey = oneToOneForiegnKey;
    }
}
